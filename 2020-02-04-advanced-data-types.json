{"version":2,"kind":"Article","sha256":"697b3aeec68314f45a421ea69d25d4cbb0990f4ae560bca4d44625a0a5e6f611","slug":"2020-02-04-advanced-data-types","location":"/CS3110/2020-02-04-Advanced-Data-Types.md","dependencies":[],"frontmatter":{"title":"Advanced Data Types","tags":["Cornell","20SP","CS3110"],"date":"2020-02-04","authors":[{"nameParsed":{"literal":"Yao Lirong","given":"Yao","family":"Lirong"},"name":"Yao Lirong","affiliations":["Cornell University"],"url":"https://yao-lirong.github.io","linkedin":"https://www.linkedin.com/in/yao-lirong/","id":"contributors-myst-generated-uid-0"}],"keywords":["Cornell","CS","Yao Lirong"],"affiliations":[{"id":"Cornell University","name":"Cornell University"}],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-04-Advanced-Data-Types.md","url":"/cornell-notes/build/2020-02-04-Advanced--ecb304f2f07ab1cbcdca9a11e6f5bff7.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"lqpjqeAm9A"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Advanced Data Types","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"LRPeegSXmM"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","key":"Ab7SEQXHaC"}],"key":"ofqGfbHtPG"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"Vr4sA19DR1"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Algebraic Data Types","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"INQa7DaMD2"}],"identifier":"algebraic-data-types","label":"Algebraic Data Types","html_id":"algebraic-data-types","implicit":true,"key":"fAPfGnomnc"},{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"以前我们的 variants 比较像 ","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"hR6HmEDpGJ"},{"type":"inlineCode","value":"enum","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"NHPWNdxOJS"},{"type":"text","value":"，但是现在我们更像一个abstract class","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"FHreKw8GJb"}],"key":"x19ic8CACl"},{"type":"comment","value":"more","key":"tx7XHYGT8k"},{"type":"code","lang":"ocaml","value":"(*definition*)\ntype t = C1 | C2 of t2| ... | Cn (*of tn*)\n(* t: 'a * 'a * ... *)\n\n(*expression*)\nC e\n---or---\nC\n(* e: (e1:'a, e2:'a, ...) *)\n\n(*pattern matching*)\nC p\n(* p: (e1:'a, e2:'a, ...) *)","position":{"start":{"line":20,"column":1},"end":{"line":34,"column":1}},"key":"qX4f7ygehu"},{"type":"paragraph","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"examples:","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"TTp9nHShcT"}],"key":"K38RnQgT85"},{"type":"code","lang":"ocaml","value":"type point = float * float \n\ntype shape =\n  | Point  of point\n  | Circle of point * float (* center and radius *)\n  | Rect   of point * point (* lower-left and \n                               upper-right corners *)\n\nlet area = function\n  | Point _ -> 0.0\n  | Circle (_,r) -> pi *. (r ** 2.0)\n  | Rect ((x1,y1),(x2,y2)) ->\n      let w = x2 -. x1 in\n      let h = y2 -. y1 in\n        w *. h\n\ntype string_or_int =\n| String of string\n| Int of int\n\ntype string_or_int_list = string_or_int list\n\nlet rec sum : string_or_int list -> int = function\n  | [] -> 0\n  | (String s)::t -> int_of_string s + sum t\n  | (Int i)::t -> i + sum t\n\nlet three = sum [String \"1\"; Int 2]","position":{"start":{"line":38,"column":1},"end":{"line":67,"column":1}},"key":"VxPzw1OwDW"},{"type":"paragraph","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"children":[{"type":"text","value":"When do we need ","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"HAz7SuzKQF"},{"type":"inlineCode","value":"[],(),{} | of","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"AMtdAKFWMU"},{"type":"text","value":"?","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"NjMML60oHn"}],"key":"qsYqtQqJN5"},{"type":"code","lang":"ocaml","value":"type node = {value:int; next:mylist}\nand mylist = Nil | Node of node","position":{"start":{"line":75,"column":1},"end":{"line":78,"column":1}},"key":"y7GEDiqB5g"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":80,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"children":[{"type":"inlineCode","value":"[]","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"OctVjRKJ9b"},{"type":"text","value":": list","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"y5z2Berd2f"}],"key":"AKxQf9obgP"},{"type":"listItem","spread":true,"position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"children":[{"type":"inlineCode","value":"()","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"Lrb8t1JcMU"},{"type":"text","value":": Constructor of a tuple","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"tCsjnGVJZ7"}],"key":"XExczqlqlG"},{"type":"listItem","spread":true,"position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"inlineCode","value":"{}","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"aoTCjJGRKP"},{"type":"text","value":": Constructor of a record","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"B0sT0JzyZq"}],"key":"ytB6DFBri7"},{"type":"listItem","spread":true,"position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"children":[{"type":"inlineCode","value":"|","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"YqQQAvodit"},{"type":"text","value":": delineate different variants inside a type","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"bThsxafuLU"}],"key":"ijX6vu0BvT"},{"type":"listItem","spread":true,"position":{"start":{"line":84,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"inlineCode","value":"of","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"HsSNG8FBwU"},{"type":"text","value":": defining the construction of an algebraic type","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"HILFoN3fca"}],"key":"kZM0fKpIom"}],"key":"O2ka1uOC3A"},{"type":"heading","depth":3,"position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"children":[{"type":"text","value":"Recursive Variants","position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"key":"U9a9zHJQIK"}],"identifier":"recursive-variants","label":"Recursive Variants","html_id":"recursive-variants","implicit":true,"key":"mj3pylgLzE"},{"type":"code","lang":"ocaml","value":"type intlist = Nil | Cons of int * intlist\n\ntype 'a tree = \n  | Leaf \n  | Node of 'a node\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}","position":{"start":{"line":90,"column":1},"end":{"line":101,"column":1}},"key":"FdZvFJs5CQ"},{"type":"heading","depth":3,"position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Parametrized Variants","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"CX8d6KobdO"}],"identifier":"parametrized-variants","label":"Parametrized Variants","html_id":"parametrized-variants","implicit":true,"key":"fup7na2dEm"},{"type":"paragraph","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"No matter what kind of types we define, either a variant, a record, or a tuple. We need the type parameter ","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"ZXs1W5EsH0"},{"type":"inlineCode","value":"'a or ('a,'b)","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"d2Sss5zpMN"},{"type":"text","value":" when we define it.","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"Ct9nB0D9JA"}],"key":"kRgSzQKz6X"},{"type":"code","lang":"ocaml","value":"(* [Option] makes it safer to return nothing*)\ntype 'a option = None | Some of 'a\n\ntype 'a mylist = Nil | Cons of 'a * 'a mylist\ntype ('a,'b) pair = {first: 'a; second: 'b}\ntype ('a,'b) test = 'a * 'b","position":{"start":{"line":107,"column":1},"end":{"line":114,"column":1}},"key":"gJAL9BANwO"},{"type":"paragraph","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"children":[{"type":"text","value":"Similarly, when you want to declare a variable that has a parametrized type, you also need to give the type parameter.","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"cJYOY159hC"}],"key":"CS580QAVnd"},{"type":"code","lang":"ocaml","value":"type 'a tree = Leaf of 'a | Node of ('a * 'a tree * 'a tree)\nlet x:'a tree = Leaf 5\nlet x:int tree = Leaf 5","position":{"start":{"line":118,"column":1},"end":{"line":122,"column":1}},"key":"MSZNkikbIo"},{"type":"paragraph","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"children":[{"type":"text","value":"If you do ","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"KPGCNBjh0J"},{"type":"inlineCode","value":"let x:tree = Leaf 5","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"XVNMdpKL8o"},{"type":"text","value":", the compiler won’t know what type you are talking about.","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"MIalMADkUy"}],"key":"GJLrfAFMyt"},{"type":"heading","depth":3,"position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"children":[{"type":"text","value":"Polymorphic Variants","position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"key":"E1GIqBsvNk"}],"identifier":"polymorphic-variants","label":"Polymorphic Variants","html_id":"polymorphic-variants","implicit":true,"key":"MIltkO5VIG"},{"type":"paragraph","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"children":[{"type":"text","value":"They would be better off with the name “anonymous variants,” because you want to use them when these variants are only used in this specific function and not anywhere else.","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"key":"dPkJ0fXYPr"}],"key":"V0HmEW5BoU"},{"type":"paragraph","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"children":[{"type":"text","value":"The constructor of polymorphic variants start with a \" ` \"","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"key":"ZXsUW6MAM4"}],"key":"psEx1Y8Rsj"},{"type":"code","lang":"ocaml","value":"(* note: no type definition *)\n\nlet f = function\n  | 0 -> `Infinity\n  | 1 -> `Finite 1\n  | n -> `Finite (-n)\n  \nval f : int -> [> `Finite of int | `Infinity ]\n\nlet lst = [`Pos 5; `Zero; `Neg (~-4); `Pos 3];;\nval lst : [> `Neg of int | `Pos of int | `Zero ] list =\n  [`Pos 5; `Zero; `Neg (-4); `Pos 3]","position":{"start":{"line":132,"column":1},"end":{"line":145,"column":1}},"key":"D0MGDq72BU"},{"type":"heading","depth":3,"position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"key":"UvZMoW7KCR"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching","implicit":true,"key":"LZi1LGOBnX"},{"type":"code","lang":"ocaml","value":"type 'a tree = \n  | Leaf \n  | Node of 'a node\n\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}\n\n(* [mem x t] returns [true] if and only if [x] is a value at some\n * node in tree [t]. \n *)\nlet rec mem x = function\n  | Leaf -> false\n  | Node {value; left; right} -> value = x || mem x left || mem x right","position":{"start":{"line":149,"column":1},"end":{"line":166,"column":1}},"key":"X87qPRMLB7"},{"type":"heading","depth":2,"position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"children":[{"type":"text","value":"Exceptions","position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"key":"Igzy2LoRLp"}],"identifier":"exceptions","label":"Exceptions","html_id":"exceptions","implicit":true,"key":"QlkLihuIvV"},{"type":"heading","depth":3,"position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"children":[{"type":"text","value":"The Basics","position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"key":"AVsgBy84Ft"}],"identifier":"the-basics","label":"The Basics","html_id":"the-basics","implicit":true,"key":"rThjO1mBA6"},{"type":"code","lang":"ocaml","value":"(*Definition: it is just a special kind of \"type\"*)\nexception E of t\n\n\n(*Call an Exception*)\nraise e\n\n(*syntactic sugar*)\nfailwith \"Not Good\"\nraise (Failure (\"Not Good\"))","position":{"start":{"line":174,"column":1},"end":{"line":185,"column":1}},"key":"sbLw0dKaNR"},{"type":"heading","depth":3,"position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"key":"QAkGAxRF50"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching-1","implicit":true,"key":"PGuI435n8S"},{"type":"paragraph","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"children":[{"type":"text","value":"The following code says: try evaluating ","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"KGMN10lu0Z"},{"type":"inlineCode","value":"e","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"L12wtTPpN6"},{"type":"text","value":". If it produces an exception packet, use the exception patterns from the original match expression to handle that packet. If it doesn’t produce an exception packet but instead produces a normal value, use the non-exception patterns from the original match expression to match that value.","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"D6fkBWC6U6"}],"key":"W1RL3i4ccL"},{"type":"code","lang":"ocaml","value":"match \n  try e with\n    | q1 -> e1\n    | ...\n    | qn -> en\nwith\n  | r1 -> e1\n  | ...\n  | rm -> em","position":{"start":{"line":191,"column":1},"end":{"line":201,"column":1}},"key":"KKZn31RbqW"}],"key":"DPVjOIL1KC"}],"key":"mnx8pykAzN"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Standard Data Types","url":"/2020-01-30-standard-data-types","group":"CS3110 Functional Programming"},"next":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"CS3110 Functional Programming"}}},"domain":"http://localhost:3000"}