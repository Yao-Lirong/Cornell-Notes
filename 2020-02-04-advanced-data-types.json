{"version":2,"kind":"Article","sha256":"697b3aeec68314f45a421ea69d25d4cbb0990f4ae560bca4d44625a0a5e6f611","slug":"2020-02-04-advanced-data-types","location":"/CS3110/2020-02-04-Advanced-Data-Types.md","dependencies":[],"frontmatter":{"title":"Advanced Data Types","tags":["Cornell","20SP","CS3110"],"date":"2020-02-04","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-04-Advanced-Data-Types.md","url":"/cornell-notes/build/2020-02-04-Advanced--9862fd6bb03c3cd309c032c87e7c32fe.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"fnOWdXqkU5"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Advanced Data Types","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"vvEXZP4pWx"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","key":"OjSEHKDcOo"}],"key":"DSSvFDab2n"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"KqsXsmLHWC"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Algebraic Data Types","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"MWXbYMnuS6"}],"identifier":"algebraic-data-types","label":"Algebraic Data Types","html_id":"algebraic-data-types","implicit":true,"key":"JDplgmufuy"},{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"以前我们的 variants 比较像 ","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"ut3u3aPXdr"},{"type":"inlineCode","value":"enum","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"ttfDuu45WP"},{"type":"text","value":"，但是现在我们更像一个abstract class","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"utRcC78c5e"}],"key":"kaFHGI6gJ7"},{"type":"comment","value":"more","key":"W3KKIUo8cu"},{"type":"code","lang":"ocaml","value":"(*definition*)\ntype t = C1 | C2 of t2| ... | Cn (*of tn*)\n(* t: 'a * 'a * ... *)\n\n(*expression*)\nC e\n---or---\nC\n(* e: (e1:'a, e2:'a, ...) *)\n\n(*pattern matching*)\nC p\n(* p: (e1:'a, e2:'a, ...) *)","position":{"start":{"line":20,"column":1},"end":{"line":34,"column":1}},"key":"ZRIwY9l3r7"},{"type":"paragraph","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"examples:","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"vkCtAwHj5x"}],"key":"ITwWTompNH"},{"type":"code","lang":"ocaml","value":"type point = float * float \n\ntype shape =\n  | Point  of point\n  | Circle of point * float (* center and radius *)\n  | Rect   of point * point (* lower-left and \n                               upper-right corners *)\n\nlet area = function\n  | Point _ -> 0.0\n  | Circle (_,r) -> pi *. (r ** 2.0)\n  | Rect ((x1,y1),(x2,y2)) ->\n      let w = x2 -. x1 in\n      let h = y2 -. y1 in\n        w *. h\n\ntype string_or_int =\n| String of string\n| Int of int\n\ntype string_or_int_list = string_or_int list\n\nlet rec sum : string_or_int list -> int = function\n  | [] -> 0\n  | (String s)::t -> int_of_string s + sum t\n  | (Int i)::t -> i + sum t\n\nlet three = sum [String \"1\"; Int 2]","position":{"start":{"line":38,"column":1},"end":{"line":67,"column":1}},"key":"P0TFmw2fcK"},{"type":"paragraph","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"children":[{"type":"text","value":"When do we need ","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"IrSJrXIk8P"},{"type":"inlineCode","value":"[],(),{} | of","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"JKhh3xzOVj"},{"type":"text","value":"?","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"UUyBe6638Y"}],"key":"dYgzyUDOel"},{"type":"code","lang":"ocaml","value":"type node = {value:int; next:mylist}\nand mylist = Nil | Node of node","position":{"start":{"line":75,"column":1},"end":{"line":78,"column":1}},"key":"R2pOdCYa8D"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":80,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"children":[{"type":"inlineCode","value":"[]","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"QA6PaVInZm"},{"type":"text","value":": list","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"XPNkYlFw1U"}],"key":"z6AvbhgHXv"},{"type":"listItem","spread":true,"position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"children":[{"type":"inlineCode","value":"()","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"AssLVS3gRo"},{"type":"text","value":": Constructor of a tuple","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"pclWUoznsD"}],"key":"tQ1k7bmMyB"},{"type":"listItem","spread":true,"position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"inlineCode","value":"{}","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"Cew7opKOQw"},{"type":"text","value":": Constructor of a record","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"J5hEmrYKGO"}],"key":"xkyhYDELuc"},{"type":"listItem","spread":true,"position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"children":[{"type":"inlineCode","value":"|","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"J3aIqUxCMu"},{"type":"text","value":": delineate different variants inside a type","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"MdOpNXHxGn"}],"key":"yZCUmaRRul"},{"type":"listItem","spread":true,"position":{"start":{"line":84,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"inlineCode","value":"of","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"yweBlbhDbX"},{"type":"text","value":": defining the construction of an algebraic type","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"UgtrjZK670"}],"key":"u898n67q2K"}],"key":"XbWE5sNzlk"},{"type":"heading","depth":3,"position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"children":[{"type":"text","value":"Recursive Variants","position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"key":"uoE2m4xOQv"}],"identifier":"recursive-variants","label":"Recursive Variants","html_id":"recursive-variants","implicit":true,"key":"vHZ9e5OBME"},{"type":"code","lang":"ocaml","value":"type intlist = Nil | Cons of int * intlist\n\ntype 'a tree = \n  | Leaf \n  | Node of 'a node\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}","position":{"start":{"line":90,"column":1},"end":{"line":101,"column":1}},"key":"gj5cvNNKB6"},{"type":"heading","depth":3,"position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Parametrized Variants","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"i77CYV5deJ"}],"identifier":"parametrized-variants","label":"Parametrized Variants","html_id":"parametrized-variants","implicit":true,"key":"lxWLpuG7yf"},{"type":"paragraph","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"No matter what kind of types we define, either a variant, a record, or a tuple. We need the type parameter ","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"lnbK34n729"},{"type":"inlineCode","value":"'a or ('a,'b)","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"APMkjJ9qHi"},{"type":"text","value":" when we define it.","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"UWKASvMdox"}],"key":"cEn3xaCKlI"},{"type":"code","lang":"ocaml","value":"(* [Option] makes it safer to return nothing*)\ntype 'a option = None | Some of 'a\n\ntype 'a mylist = Nil | Cons of 'a * 'a mylist\ntype ('a,'b) pair = {first: 'a; second: 'b}\ntype ('a,'b) test = 'a * 'b","position":{"start":{"line":107,"column":1},"end":{"line":114,"column":1}},"key":"p6HEQWo7Qq"},{"type":"paragraph","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"children":[{"type":"text","value":"Similarly, when you want to declare a variable that has a parametrized type, you also need to give the type parameter.","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"bQCm2VBwAI"}],"key":"xaUAYhf3VY"},{"type":"code","lang":"ocaml","value":"type 'a tree = Leaf of 'a | Node of ('a * 'a tree * 'a tree)\nlet x:'a tree = Leaf 5\nlet x:int tree = Leaf 5","position":{"start":{"line":118,"column":1},"end":{"line":122,"column":1}},"key":"j29jTOk6ia"},{"type":"paragraph","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"children":[{"type":"text","value":"If you do ","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"hRjWjZ247I"},{"type":"inlineCode","value":"let x:tree = Leaf 5","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"rArfo4PwiK"},{"type":"text","value":", the compiler won’t know what type you are talking about.","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"x2wnnufbEJ"}],"key":"HzzIiMDOv1"},{"type":"heading","depth":3,"position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"children":[{"type":"text","value":"Polymorphic Variants","position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"key":"ttgbkIg5RA"}],"identifier":"polymorphic-variants","label":"Polymorphic Variants","html_id":"polymorphic-variants","implicit":true,"key":"ZsvvScc6oY"},{"type":"paragraph","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"children":[{"type":"text","value":"They would be better off with the name “anonymous variants,” because you want to use them when these variants are only used in this specific function and not anywhere else.","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"key":"OYd8043O4e"}],"key":"xJMSV7OQbf"},{"type":"paragraph","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"children":[{"type":"text","value":"The constructor of polymorphic variants start with a \" ` \"","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"key":"m5CALA9kNm"}],"key":"C5kBhU3a2P"},{"type":"code","lang":"ocaml","value":"(* note: no type definition *)\n\nlet f = function\n  | 0 -> `Infinity\n  | 1 -> `Finite 1\n  | n -> `Finite (-n)\n  \nval f : int -> [> `Finite of int | `Infinity ]\n\nlet lst = [`Pos 5; `Zero; `Neg (~-4); `Pos 3];;\nval lst : [> `Neg of int | `Pos of int | `Zero ] list =\n  [`Pos 5; `Zero; `Neg (-4); `Pos 3]","position":{"start":{"line":132,"column":1},"end":{"line":145,"column":1}},"key":"EZEBt9dYGm"},{"type":"heading","depth":3,"position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"key":"n9C5Q3I76e"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching","implicit":true,"key":"YDq3GOoBIL"},{"type":"code","lang":"ocaml","value":"type 'a tree = \n  | Leaf \n  | Node of 'a node\n\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}\n\n(* [mem x t] returns [true] if and only if [x] is a value at some\n * node in tree [t]. \n *)\nlet rec mem x = function\n  | Leaf -> false\n  | Node {value; left; right} -> value = x || mem x left || mem x right","position":{"start":{"line":149,"column":1},"end":{"line":166,"column":1}},"key":"MkejtcRfKr"},{"type":"heading","depth":2,"position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"children":[{"type":"text","value":"Exceptions","position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"key":"JoJLfBhNoq"}],"identifier":"exceptions","label":"Exceptions","html_id":"exceptions","implicit":true,"key":"klDJcqse4v"},{"type":"heading","depth":3,"position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"children":[{"type":"text","value":"The Basics","position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"key":"xHIMfWPna1"}],"identifier":"the-basics","label":"The Basics","html_id":"the-basics","implicit":true,"key":"kzA2f6CHEk"},{"type":"code","lang":"ocaml","value":"(*Definition: it is just a special kind of \"type\"*)\nexception E of t\n\n\n(*Call an Exception*)\nraise e\n\n(*syntactic sugar*)\nfailwith \"Not Good\"\nraise (Failure (\"Not Good\"))","position":{"start":{"line":174,"column":1},"end":{"line":185,"column":1}},"key":"FuQOMU6tzM"},{"type":"heading","depth":3,"position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"key":"ZHMUU3l7au"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching-1","implicit":true,"key":"sItXnoQCId"},{"type":"paragraph","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"children":[{"type":"text","value":"The following code says: try evaluating ","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"weHutJ0czg"},{"type":"inlineCode","value":"e","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"MpzFpW1uLb"},{"type":"text","value":". If it produces an exception packet, use the exception patterns from the original match expression to handle that packet. If it doesn’t produce an exception packet but instead produces a normal value, use the non-exception patterns from the original match expression to match that value.","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"ufNjv4WPob"}],"key":"GAqMJVmXGn"},{"type":"code","lang":"ocaml","value":"match \n  try e with\n    | q1 -> e1\n    | ...\n    | qn -> en\nwith\n  | r1 -> e1\n  | ...\n  | rm -> em","position":{"start":{"line":191,"column":1},"end":{"line":201,"column":1}},"key":"Lwk0w8wv8t"}],"key":"UkdqoBqwf8"}],"key":"l52yv6pjPV"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Standard Data Types","url":"/2020-01-30-standard-data-types","group":"C S3110"},"next":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"C S3110"}}},"domain":"http://localhost:3000"}