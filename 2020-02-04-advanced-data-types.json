{"version":2,"kind":"Article","sha256":"697b3aeec68314f45a421ea69d25d4cbb0990f4ae560bca4d44625a0a5e6f611","slug":"2020-02-04-advanced-data-types","location":"/CS3110/2020-02-04-Advanced-Data-Types.md","dependencies":[],"frontmatter":{"title":"Advanced Data Types","tags":["Cornell","20SP","CS3110"],"date":"2020-02-04","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-04-Advanced-Data-Types.md","url":"/build/2020-02-04-Advanced--9862fd6bb03c3cd309c032c87e7c32fe.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"mx5RbhyRyS"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Advanced Data Types","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"qjPWMH44qa"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/data/advanced.html","key":"DpGOpkHe7L"}],"key":"Gdz0eAhZRb"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"FU0GZ1VoWz"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Algebraic Data Types","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"D3v869gFS8"}],"identifier":"algebraic-data-types","label":"Algebraic Data Types","html_id":"algebraic-data-types","implicit":true,"key":"gx7jzKvhSy"},{"type":"paragraph","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"以前我们的 variants 比较像 ","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"GVI38drpMu"},{"type":"inlineCode","value":"enum","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"bfHV7gbLpV"},{"type":"text","value":"，但是现在我们更像一个abstract class","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"OjPjlRdMxm"}],"key":"kIc2pxkZA0"},{"type":"comment","value":"more","key":"XGDku2PebP"},{"type":"code","lang":"ocaml","value":"(*definition*)\ntype t = C1 | C2 of t2| ... | Cn (*of tn*)\n(* t: 'a * 'a * ... *)\n\n(*expression*)\nC e\n---or---\nC\n(* e: (e1:'a, e2:'a, ...) *)\n\n(*pattern matching*)\nC p\n(* p: (e1:'a, e2:'a, ...) *)","position":{"start":{"line":20,"column":1},"end":{"line":34,"column":1}},"key":"UUCFC9Y9gE"},{"type":"paragraph","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"examples:","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"lbgGUqCScd"}],"key":"mkAVmfgFRB"},{"type":"code","lang":"ocaml","value":"type point = float * float \n\ntype shape =\n  | Point  of point\n  | Circle of point * float (* center and radius *)\n  | Rect   of point * point (* lower-left and \n                               upper-right corners *)\n\nlet area = function\n  | Point _ -> 0.0\n  | Circle (_,r) -> pi *. (r ** 2.0)\n  | Rect ((x1,y1),(x2,y2)) ->\n      let w = x2 -. x1 in\n      let h = y2 -. y1 in\n        w *. h\n\ntype string_or_int =\n| String of string\n| Int of int\n\ntype string_or_int_list = string_or_int list\n\nlet rec sum : string_or_int list -> int = function\n  | [] -> 0\n  | (String s)::t -> int_of_string s + sum t\n  | (Int i)::t -> i + sum t\n\nlet three = sum [String \"1\"; Int 2]","position":{"start":{"line":38,"column":1},"end":{"line":67,"column":1}},"key":"ePeTO8gk1a"},{"type":"paragraph","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"children":[{"type":"text","value":"When do we need ","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"fUBvAv3IUd"},{"type":"inlineCode","value":"[],(),{} | of","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"OgHUWafEqW"},{"type":"text","value":"?","position":{"start":{"line":73,"column":1},"end":{"line":73,"column":1}},"key":"gHGTYWfWWB"}],"key":"FaeUXT1cHy"},{"type":"code","lang":"ocaml","value":"type node = {value:int; next:mylist}\nand mylist = Nil | Node of node","position":{"start":{"line":75,"column":1},"end":{"line":78,"column":1}},"key":"GpxLCpCYxs"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":80,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"children":[{"type":"inlineCode","value":"[]","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"Y739rRqJe1"},{"type":"text","value":": list","position":{"start":{"line":80,"column":1},"end":{"line":80,"column":1}},"key":"JhXI8iO2xz"}],"key":"qHYSkAPDLC"},{"type":"listItem","spread":true,"position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"children":[{"type":"inlineCode","value":"()","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"fjmAVnMa6I"},{"type":"text","value":": Constructor of a tuple","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"aYPsIOlW3g"}],"key":"G7l955e7SV"},{"type":"listItem","spread":true,"position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"inlineCode","value":"{}","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"ATv0tBxcEl"},{"type":"text","value":": Constructor of a record","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"OX3xmiyUga"}],"key":"ywJvfsieht"},{"type":"listItem","spread":true,"position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"children":[{"type":"inlineCode","value":"|","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"le4EpcBGX4"},{"type":"text","value":": delineate different variants inside a type","position":{"start":{"line":83,"column":1},"end":{"line":83,"column":1}},"key":"E9hTR7kNkO"}],"key":"QSvxT89Mod"},{"type":"listItem","spread":true,"position":{"start":{"line":84,"column":1},"end":{"line":87,"column":1}},"children":[{"type":"inlineCode","value":"of","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"PrxoCWGhPM"},{"type":"text","value":": defining the construction of an algebraic type","position":{"start":{"line":84,"column":1},"end":{"line":84,"column":1}},"key":"jejpr3IBgM"}],"key":"lWf88OsxQu"}],"key":"gUc2HLrGH4"},{"type":"heading","depth":3,"position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"children":[{"type":"text","value":"Recursive Variants","position":{"start":{"line":88,"column":1},"end":{"line":88,"column":1}},"key":"xV02tpeXyg"}],"identifier":"recursive-variants","label":"Recursive Variants","html_id":"recursive-variants","implicit":true,"key":"Tadtg6AqDN"},{"type":"code","lang":"ocaml","value":"type intlist = Nil | Cons of int * intlist\n\ntype 'a tree = \n  | Leaf \n  | Node of 'a node\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}","position":{"start":{"line":90,"column":1},"end":{"line":101,"column":1}},"key":"t11d2UfE9b"},{"type":"heading","depth":3,"position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Parametrized Variants","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"g91VLL85U8"}],"identifier":"parametrized-variants","label":"Parametrized Variants","html_id":"parametrized-variants","implicit":true,"key":"GZKE5FjVoL"},{"type":"paragraph","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"No matter what kind of types we define, either a variant, a record, or a tuple. We need the type parameter ","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"qkqBC5koPM"},{"type":"inlineCode","value":"'a or ('a,'b)","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"od54zsVzPE"},{"type":"text","value":" when we define it.","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"UKeE0yEmNH"}],"key":"hWD5E2Bhcr"},{"type":"code","lang":"ocaml","value":"(* [Option] makes it safer to return nothing*)\ntype 'a option = None | Some of 'a\n\ntype 'a mylist = Nil | Cons of 'a * 'a mylist\ntype ('a,'b) pair = {first: 'a; second: 'b}\ntype ('a,'b) test = 'a * 'b","position":{"start":{"line":107,"column":1},"end":{"line":114,"column":1}},"key":"Rq1MTlrya4"},{"type":"paragraph","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"children":[{"type":"text","value":"Similarly, when you want to declare a variable that has a parametrized type, you also need to give the type parameter.","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"JMcV6XAPKw"}],"key":"BJydNPM5Hj"},{"type":"code","lang":"ocaml","value":"type 'a tree = Leaf of 'a | Node of ('a * 'a tree * 'a tree)\nlet x:'a tree = Leaf 5\nlet x:int tree = Leaf 5","position":{"start":{"line":118,"column":1},"end":{"line":122,"column":1}},"key":"PEqFOD53L1"},{"type":"paragraph","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"children":[{"type":"text","value":"If you do ","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"vNy6BbYsFa"},{"type":"inlineCode","value":"let x:tree = Leaf 5","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"RybrI8t2SJ"},{"type":"text","value":", the compiler won’t know what type you are talking about.","position":{"start":{"line":124,"column":1},"end":{"line":124,"column":1}},"key":"gCAmJgZ46D"}],"key":"cpxDh4v38x"},{"type":"heading","depth":3,"position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"children":[{"type":"text","value":"Polymorphic Variants","position":{"start":{"line":126,"column":1},"end":{"line":126,"column":1}},"key":"PnllyAzBno"}],"identifier":"polymorphic-variants","label":"Polymorphic Variants","html_id":"polymorphic-variants","implicit":true,"key":"aGztOV0sR7"},{"type":"paragraph","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"children":[{"type":"text","value":"They would be better off with the name “anonymous variants,” because you want to use them when these variants are only used in this specific function and not anywhere else.","position":{"start":{"line":128,"column":1},"end":{"line":128,"column":1}},"key":"Us8KdnJKtg"}],"key":"frVfhdUwbA"},{"type":"paragraph","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"children":[{"type":"text","value":"The constructor of polymorphic variants start with a \" ` \"","position":{"start":{"line":130,"column":1},"end":{"line":130,"column":1}},"key":"bDmoYq38dj"}],"key":"awTlDjxJ9w"},{"type":"code","lang":"ocaml","value":"(* note: no type definition *)\n\nlet f = function\n  | 0 -> `Infinity\n  | 1 -> `Finite 1\n  | n -> `Finite (-n)\n  \nval f : int -> [> `Finite of int | `Infinity ]\n\nlet lst = [`Pos 5; `Zero; `Neg (~-4); `Pos 3];;\nval lst : [> `Neg of int | `Pos of int | `Zero ] list =\n  [`Pos 5; `Zero; `Neg (-4); `Pos 3]","position":{"start":{"line":132,"column":1},"end":{"line":145,"column":1}},"key":"qciir4thT7"},{"type":"heading","depth":3,"position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":147,"column":1},"end":{"line":147,"column":1}},"key":"Qoc6POrGBR"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching","implicit":true,"key":"MpRvFMIG6B"},{"type":"code","lang":"ocaml","value":"type 'a tree = \n  | Leaf \n  | Node of 'a node\n\nand 'a node = { \n  value: 'a; \n  left:  'a tree; \n  right: 'a tree\n}\n\n(* [mem x t] returns [true] if and only if [x] is a value at some\n * node in tree [t]. \n *)\nlet rec mem x = function\n  | Leaf -> false\n  | Node {value; left; right} -> value = x || mem x left || mem x right","position":{"start":{"line":149,"column":1},"end":{"line":166,"column":1}},"key":"nm2E19Txzj"},{"type":"heading","depth":2,"position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"children":[{"type":"text","value":"Exceptions","position":{"start":{"line":170,"column":1},"end":{"line":170,"column":1}},"key":"P38MPMeenA"}],"identifier":"exceptions","label":"Exceptions","html_id":"exceptions","implicit":true,"key":"hawL40I9vQ"},{"type":"heading","depth":3,"position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"children":[{"type":"text","value":"The Basics","position":{"start":{"line":172,"column":1},"end":{"line":172,"column":1}},"key":"tKoJaPZBTV"}],"identifier":"the-basics","label":"The Basics","html_id":"the-basics","implicit":true,"key":"wUAY3Yzp6I"},{"type":"code","lang":"ocaml","value":"(*Definition: it is just a special kind of \"type\"*)\nexception E of t\n\n\n(*Call an Exception*)\nraise e\n\n(*syntactic sugar*)\nfailwith \"Not Good\"\nraise (Failure (\"Not Good\"))","position":{"start":{"line":174,"column":1},"end":{"line":185,"column":1}},"key":"sYObtEwOCN"},{"type":"heading","depth":3,"position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":187,"column":1},"end":{"line":187,"column":1}},"key":"o9l3vzqfQw"}],"identifier":"pattern-matching","label":"Pattern Matching","html_id":"pattern-matching-1","implicit":true,"key":"QjZgXgNnTK"},{"type":"paragraph","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"children":[{"type":"text","value":"The following code says: try evaluating ","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"kx3dChUcz1"},{"type":"inlineCode","value":"e","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"hoXAGitPUw"},{"type":"text","value":". If it produces an exception packet, use the exception patterns from the original match expression to handle that packet. If it doesn’t produce an exception packet but instead produces a normal value, use the non-exception patterns from the original match expression to match that value.","position":{"start":{"line":189,"column":1},"end":{"line":189,"column":1}},"key":"y98Jj8f4Dt"}],"key":"PmrFx0Erfp"},{"type":"code","lang":"ocaml","value":"match \n  try e with\n    | q1 -> e1\n    | ...\n    | qn -> en\nwith\n  | r1 -> e1\n  | ...\n  | rm -> em","position":{"start":{"line":191,"column":1},"end":{"line":201,"column":1}},"key":"TlfaUfkVoj"}],"key":"dwyYYMiFUH"}],"key":"Pj4iudz7Y3"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Standard Data Types","url":"/2020-01-30-standard-data-types","group":"C S3110"},"next":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"C S3110"}}},"domain":"http://localhost:3000"}