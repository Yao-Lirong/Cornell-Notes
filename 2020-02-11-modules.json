{"version":2,"kind":"Article","sha256":"7c228b6bf6cf3854b535b0af059a0cf1f8a2c62aa291eca4be6d9b37b2b6a346","slug":"2020-02-11-modules","location":"/CS3110/2020-02-11-Modules.md","dependencies":[],"frontmatter":{"title":"Modules","tags":["Cornell","20SP","CS3110"],"date":"2020-02-11","authors":[{"nameParsed":{"literal":"Yao Lirong","given":"Yao","family":"Lirong"},"name":"Yao Lirong","affiliations":["Cornell University"],"url":"https://yao-lirong.github.io","linkedin":"https://www.linkedin.com/in/yao-lirong/","id":"contributors-myst-generated-uid-0"}],"keywords":["Cornell","CS","Yao Lirong"],"affiliations":[{"id":"Cornell University","name":"Cornell University"}],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-11-Modules.md","url":"/cornell-notes/build/2020-02-11-Modules-34d51079b517adeb5676bff008f46914.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"r4yEqTzuER"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"OCaml Modules","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"BMyclkbqum"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","key":"yt4niJ3ona"}],"key":"K9m7cSTkF4"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"fhmmpBXrjq"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Structures","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"UTwr219NZ8"}],"identifier":"structures","label":"Structures","html_id":"structures","implicit":true,"key":"Sk6daqULof"},{"type":"heading","depth":3,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"kkq0DmtEys"}],"identifier":"semantics","label":"Semantics","html_id":"semantics","implicit":true,"key":"DvVikfeIdr"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"The first letter of a module’s name should be capitalized.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"oSBJz4kWyJ"}],"key":"PlMN2Ciq1j"},{"type":"code","lang":"ocaml","value":"module ModuleName = struct \n  (* definitions *)\nend","position":{"start":{"line":20,"column":1},"end":{"line":24,"column":1}},"key":"Cwrigk4Nr3"},{"type":"comment","value":"more","key":"mMLNQgWc5z"},{"type":"paragraph","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"You can access the variables / methods in a module by ","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"pJcbSgNJz7"},{"type":"inlineCode","value":"Module.method","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"rlDTMoGfrl"}],"key":"bF0dX09zig"},{"type":"code","lang":"ocaml","value":"let x = ModuleName.empty;;\nx.peek;;","position":{"start":{"line":30,"column":1},"end":{"line":33,"column":1}},"key":"Jmk5T99Noj"},{"type":"heading","depth":2,"position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"children":[{"type":"text","value":"Signatures","position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"key":"TZ7Gv4uEMU"}],"identifier":"signatures","label":"Signatures","html_id":"signatures","implicit":true,"key":"zpSGQPEPUe"},{"type":"heading","depth":3,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"Zm2muT7A6S"}],"identifier":"semantics","label":"Semantics","html_id":"semantics-1","implicit":true,"key":"fG4dynVQAm"},{"type":"paragraph","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"children":[{"type":"text","value":"Signature is a collections of declarations; not evaluated, just type checked.","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"key":"sW1CpKIbPv"}],"key":"q5wtl6ryYW"},{"type":"code","lang":"ocaml","value":"module type ModuleTypeName = sig \n  (* declarations *)\nend\n\nmodule type Stack = sig\n  type 'a stack\n  val empty    : 'a stack\n  val is_empty : 'a stack -> bool\n  val push     : 'a -> 'a stack -> 'a stack\n  val peek     : 'a stack -> 'a\n  val pop      : 'a stack -> 'a stack\nend","position":{"start":{"line":43,"column":1},"end":{"line":56,"column":1}},"key":"dMcGZ3mMk1"},{"type":"paragraph","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"children":[{"type":"text","value":"A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature.","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"key":"zgTenB7jrY"}],"key":"EWfD9tRYbP"},{"type":"paragraph","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"children":[{"type":"text","value":"If you don’t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we don’t have to do that. It’s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X.","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"key":"EI60jtvS0h"}],"key":"HCfbXuAzsJ"},{"type":"heading","depth":3,"position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"children":[{"type":"text","value":"Abstraction","position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"key":"Ec1wo6ClZk"}],"identifier":"abstraction","label":"Abstraction","html_id":"abstraction","implicit":true,"key":"djEvUuUQCU"},{"type":"paragraph","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"children":[{"type":"text","value":"You can also specify that this module as a type of some signature by providing a module type annotation  ","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"v9TPoIEN2h"},{"type":"inlineCode","value":": Stack","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"cwXObXrYRz"},{"type":"text","value":". After adding this, everything inside that module will be come abstract and hidden from view.","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"BhfM62KgWn"}],"key":"Ut2Plio7xX"},{"type":"code","lang":"ocaml","value":"module type Arith = sig\n  type t\n  val zero  : t\n  val one   : t\n  val (+)   : t -> t -> t\n  val ( * ) : t -> t -> t\n  val (~-)  : t -> t\nend\n\nmodule Ints : Arith = struct\n  type t    = int\n  let zero  = 0\n  let one   = 1\n  let (+)   = Stdlib.(+)\n  let ( * ) = Stdlib.( * )\n  let (~-)  = Stdlib.(~-)\nend","position":{"start":{"line":66,"column":1},"end":{"line":84,"column":1}},"key":"XxRjXbOBQO"},{"type":"paragraph","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"children":[{"type":"text","value":"Outside of the module ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"gdTJMFHGG0"},{"type":"inlineCode","value":"Ints","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"Quu9y888x4"},{"type":"text","value":", the expression ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"fItVma88XT"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"zPJfsM3dYX"},{"type":"text","value":" is perfectly fine, but ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"qLbKVDhOLd"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"FJva636RGH"},{"type":"text","value":" is not, because ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"dEOXmxPryt"},{"type":"inlineCode","value":"t","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"ggS6CLREVN"},{"type":"text","value":" is abstract: outside the module no one is permitted to know that ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"kJ6SB3zTw0"},{"type":"inlineCode","value":"t = int","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"g1WglRGAAt"},{"type":"text","value":". In fact, the toplevel can’t even give us good output about what the sum of one and one is!","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"zSsi0NYyvP"}],"key":"cyXx0AeUwN"},{"type":"code","lang":"ocaml","value":"# Ints.(one + one);;\n- : Ints.t = <abstr>","position":{"start":{"line":88,"column":1},"end":{"line":91,"column":1}},"key":"sRf2ArDZBU"},{"type":"heading","depth":3,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Sharing Constraint","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"hFnLJvrZYG"}],"identifier":"sharing-constraint","label":"Sharing Constraint","html_id":"sharing-constraint","implicit":true,"key":"mMZnAxBP68"},{"type":"paragraph","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"OCaml lets you write ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"hRQvGOtXXg"},{"type":"emphasis","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"sharing constraints","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"qRsOfvUHT3"}],"key":"eP4EzArHrF"},{"type":"text","value":" that refine a signature by specifying equations that must hold on the abstract types in that signature. If ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"sBjNZiDHwj"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"KEOKn9jNvF"},{"type":"text","value":" is a module type containing an abstract type ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"tskCi5RBVG"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"pkbaQwdHHq"},{"type":"text","value":", then ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"SVN27TpOu1"},{"type":"inlineCode","value":"T with type t = int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"mSgwEEClj0"},{"type":"text","value":" is a new module type that is the same as ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ffaFRsHHs5"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"pL35GanqoX"},{"type":"text","value":", except that ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"JSabHRmR5m"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"QioL9AImy8"},{"type":"text","value":" is known to be ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ed8gSoVOzC"},{"type":"inlineCode","value":"int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"jMiZk2zap0"},{"type":"text","value":". For example, we could write:","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"kLVxHAbzoQ"}],"key":"BqOH9AA1cW"},{"type":"code","lang":"ocaml","value":"module Ints : (Arith with type t = int) = struct\n  (* all of Ints as before *)\nend","position":{"start":{"line":97,"column":1},"end":{"line":101,"column":1}},"key":"UCx1W4DfYH"},{"type":"paragraph","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Now both ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"WnhCpmHTyE"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"QVoHbh7x1Q"},{"type":"text","value":" and ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"SEtAdKH4sw"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"gufak5ZqNW"},{"type":"text","value":" are legal.","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"O4PHRp7vOQ"}],"key":"WDNJl6FCLZ"},{"type":"heading","depth":3,"position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"Modules and the Top Level","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"aYByT3jwT5"}],"identifier":"modules-and-the-top-level","label":"Modules and the Top Level","html_id":"modules-and-the-top-level","implicit":true,"key":"MBkRZTnMMc"},{"type":"paragraph","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"Well, apparently you cannot remember everything about how to import a library into OCaml and you don’t have to. So just refer to ","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"uIfecCWN5C"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"this site","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"y5fP8nBFGM"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","key":"STcbFSBh4O"}],"key":"FNt7C4Q1jC"}],"key":"ZZwAvUewyK"}],"key":"vJGWKZ0Q2L"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"CS3110 Functional Programming"},"next":{"title":"Code Reuse with Modules","url":"/2020-02-13-code-reuse-with-modules","group":"CS3110 Functional Programming"}}},"domain":"http://localhost:3000"}