{"version":2,"kind":"Article","sha256":"7c228b6bf6cf3854b535b0af059a0cf1f8a2c62aa291eca4be6d9b37b2b6a346","slug":"2020-02-11-modules","location":"/CS3110/2020-02-11-Modules.md","dependencies":[],"frontmatter":{"title":"Modules","tags":["Cornell","20SP","CS3110"],"date":"2020-02-11","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-11-Modules.md","url":"/build/2020-02-11-Modules-387880d5f7dacc9c0769791ed906f53a.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"fXaxe2wVJA"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"OCaml Modules","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"y9pCBPY0F5"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","key":"nvZbMYRraG"}],"key":"ZElCG7sBaO"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"uS2mmgyOPq"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Structures","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"euVFR7KZPx"}],"identifier":"structures","label":"Structures","html_id":"structures","implicit":true,"key":"po8PfBWzfM"},{"type":"heading","depth":3,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"KxwgHh1ivR"}],"identifier":"semantics","label":"Semantics","html_id":"semantics","implicit":true,"key":"OZcPVFBsn1"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"The first letter of a module’s name should be capitalized.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"UAxVvXmnWb"}],"key":"MnaJfkU3cF"},{"type":"code","lang":"ocaml","value":"module ModuleName = struct \n  (* definitions *)\nend","position":{"start":{"line":20,"column":1},"end":{"line":24,"column":1}},"key":"hf7oDkzy0x"},{"type":"comment","value":"more","key":"V3OAyUg3yZ"},{"type":"paragraph","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"You can access the variables / methods in a module by ","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"iNxDc9TWEN"},{"type":"inlineCode","value":"Module.method","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"UQCnh5v80e"}],"key":"PPpOtJoQgH"},{"type":"code","lang":"ocaml","value":"let x = ModuleName.empty;;\nx.peek;;","position":{"start":{"line":30,"column":1},"end":{"line":33,"column":1}},"key":"CdTnajw3ow"},{"type":"heading","depth":2,"position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"children":[{"type":"text","value":"Signatures","position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"key":"RqcKwfMmpS"}],"identifier":"signatures","label":"Signatures","html_id":"signatures","implicit":true,"key":"CzoWKw9s4P"},{"type":"heading","depth":3,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"VJcnJSWYpN"}],"identifier":"semantics","label":"Semantics","html_id":"semantics-1","implicit":true,"key":"teahvYgjHi"},{"type":"paragraph","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"children":[{"type":"text","value":"Signature is a collections of declarations; not evaluated, just type checked.","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"key":"Qp95oBviy9"}],"key":"twE6PleDd7"},{"type":"code","lang":"ocaml","value":"module type ModuleTypeName = sig \n  (* declarations *)\nend\n\nmodule type Stack = sig\n  type 'a stack\n  val empty    : 'a stack\n  val is_empty : 'a stack -> bool\n  val push     : 'a -> 'a stack -> 'a stack\n  val peek     : 'a stack -> 'a\n  val pop      : 'a stack -> 'a stack\nend","position":{"start":{"line":43,"column":1},"end":{"line":56,"column":1}},"key":"bt7MjgmkPD"},{"type":"paragraph","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"children":[{"type":"text","value":"A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature.","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"key":"H94mYpAxXg"}],"key":"hKN4WtCVwN"},{"type":"paragraph","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"children":[{"type":"text","value":"If you don’t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we don’t have to do that. It’s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X.","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"key":"yFYnSzhYJ0"}],"key":"jjh7YSPU4z"},{"type":"heading","depth":3,"position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"children":[{"type":"text","value":"Abstraction","position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"key":"VbtiwnmCkR"}],"identifier":"abstraction","label":"Abstraction","html_id":"abstraction","implicit":true,"key":"vT9ph9Ba4l"},{"type":"paragraph","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"children":[{"type":"text","value":"You can also specify that this module as a type of some signature by providing a module type annotation  ","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"PhLuwcRZpe"},{"type":"inlineCode","value":": Stack","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"h9jZSSxeVR"},{"type":"text","value":". After adding this, everything inside that module will be come abstract and hidden from view.","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"lCkbZnI2rY"}],"key":"PGRf22LFBW"},{"type":"code","lang":"ocaml","value":"module type Arith = sig\n  type t\n  val zero  : t\n  val one   : t\n  val (+)   : t -> t -> t\n  val ( * ) : t -> t -> t\n  val (~-)  : t -> t\nend\n\nmodule Ints : Arith = struct\n  type t    = int\n  let zero  = 0\n  let one   = 1\n  let (+)   = Stdlib.(+)\n  let ( * ) = Stdlib.( * )\n  let (~-)  = Stdlib.(~-)\nend","position":{"start":{"line":66,"column":1},"end":{"line":84,"column":1}},"key":"kCZhqDKjbs"},{"type":"paragraph","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"children":[{"type":"text","value":"Outside of the module ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"XcEwD8gxl4"},{"type":"inlineCode","value":"Ints","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"puWLOjdvDG"},{"type":"text","value":", the expression ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"vajVcA7zRg"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"tXTeERzbma"},{"type":"text","value":" is perfectly fine, but ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"S50Auu66KL"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"PqO5FQ0jFu"},{"type":"text","value":" is not, because ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"LqSPgM747u"},{"type":"inlineCode","value":"t","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"Da54eKBag8"},{"type":"text","value":" is abstract: outside the module no one is permitted to know that ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"faWIocOzhH"},{"type":"inlineCode","value":"t = int","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"ZBNae0h6rx"},{"type":"text","value":". In fact, the toplevel can’t even give us good output about what the sum of one and one is!","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"v8rhh3XkHv"}],"key":"jLIY1coTV5"},{"type":"code","lang":"ocaml","value":"# Ints.(one + one);;\n- : Ints.t = <abstr>","position":{"start":{"line":88,"column":1},"end":{"line":91,"column":1}},"key":"o2iAXX9tqR"},{"type":"heading","depth":3,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Sharing Constraint","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"fm5dIBjuHV"}],"identifier":"sharing-constraint","label":"Sharing Constraint","html_id":"sharing-constraint","implicit":true,"key":"r4fkLGl93M"},{"type":"paragraph","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"OCaml lets you write ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"OKNdqJ5mno"},{"type":"emphasis","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"sharing constraints","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"MaiFqGi16Y"}],"key":"zYSQ5hETyu"},{"type":"text","value":" that refine a signature by specifying equations that must hold on the abstract types in that signature. If ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"yJIgXVZmdZ"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"b0oNIlfTN3"},{"type":"text","value":" is a module type containing an abstract type ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ah9693EE7z"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"v19oBXzScY"},{"type":"text","value":", then ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"HwnFDUl8Pq"},{"type":"inlineCode","value":"T with type t = int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"Eh4qYPCeF8"},{"type":"text","value":" is a new module type that is the same as ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"l7JjvZWbYx"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"zbYIIFrHkC"},{"type":"text","value":", except that ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"gkjbQo1fF4"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"oO3APEsnuA"},{"type":"text","value":" is known to be ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"C99kwfF0FC"},{"type":"inlineCode","value":"int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"IAlU0qhcba"},{"type":"text","value":". For example, we could write:","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"OCpa5aF0a4"}],"key":"vNGTntLwSa"},{"type":"code","lang":"ocaml","value":"module Ints : (Arith with type t = int) = struct\n  (* all of Ints as before *)\nend","position":{"start":{"line":97,"column":1},"end":{"line":101,"column":1}},"key":"FGOuv8Wl4y"},{"type":"paragraph","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Now both ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"kpCKZJqAPG"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"DS6yZYlqdu"},{"type":"text","value":" and ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"OCc50fjL4S"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"FD6ZUhTxeR"},{"type":"text","value":" are legal.","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"XAkiEMSJEA"}],"key":"rsN8M6oKcH"},{"type":"heading","depth":3,"position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"Modules and the Top Level","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"nM8pa9oSD0"}],"identifier":"modules-and-the-top-level","label":"Modules and the Top Level","html_id":"modules-and-the-top-level","implicit":true,"key":"vwS58CbLy5"},{"type":"paragraph","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"Well, apparently you cannot remember everything about how to import a library into OCaml and you don’t have to. So just refer to ","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"bC0Pbg6qbu"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"this site","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"nl2o2isGkO"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","key":"rFPlS5fNSD"}],"key":"pV9ZEvPQsf"}],"key":"OgIuMhLLqm"}],"key":"V6OLBcNGKO"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"C S3110"},"next":{"title":"Code Reuse with Modules","url":"/2020-02-13-code-reuse-with-modules","group":"C S3110"}}},"domain":"http://localhost:3000"}