{"version":2,"kind":"Article","sha256":"7c228b6bf6cf3854b535b0af059a0cf1f8a2c62aa291eca4be6d9b37b2b6a346","slug":"2020-02-11-modules","location":"/CS3110/2020-02-11-Modules.md","dependencies":[],"frontmatter":{"title":"Modules","tags":["Cornell","20SP","CS3110"],"date":"2020-02-11","authors":[{"nameParsed":{"literal":"Yao Lirong","given":"Yao","family":"Lirong"},"name":"Yao Lirong","affiliations":["Cornell University"],"url":"https://yao-lirong.github.io","linkedin":"https://www.linkedin.com/in/yao-lirong/","id":"contributors-myst-generated-uid-0"}],"keywords":["Cornell","CS","Yao Lirong"],"affiliations":[{"id":"Cornell University","name":"Cornell University"}],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-11-Modules.md","url":"/cornell-notes/build/2020-02-11-Modules-34d51079b517adeb5676bff008f46914.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"NrMy2vzob9"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"OCaml Modules","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"ntoTChb4Oz"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","key":"ABK1yQgL22"}],"key":"mIznOP0MqW"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"YhU4CQCIIk"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Structures","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"ho0ubqVB4P"}],"identifier":"structures","label":"Structures","html_id":"structures","implicit":true,"key":"bMM34fhfBT"},{"type":"heading","depth":3,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"W9JeDNDJkI"}],"identifier":"semantics","label":"Semantics","html_id":"semantics","implicit":true,"key":"E4bJ0o5r0P"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"The first letter of a module’s name should be capitalized.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"ROh8GSS8h6"}],"key":"LKaHBRlPE8"},{"type":"code","lang":"ocaml","value":"module ModuleName = struct \n  (* definitions *)\nend","position":{"start":{"line":20,"column":1},"end":{"line":24,"column":1}},"key":"SN3QR3JCaY"},{"type":"comment","value":"more","key":"fZe0d4TKR8"},{"type":"paragraph","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"You can access the variables / methods in a module by ","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"qeWCBRFJ9q"},{"type":"inlineCode","value":"Module.method","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"NoN6XBtk8z"}],"key":"THp8tWv6BG"},{"type":"code","lang":"ocaml","value":"let x = ModuleName.empty;;\nx.peek;;","position":{"start":{"line":30,"column":1},"end":{"line":33,"column":1}},"key":"NmaYmmKvf1"},{"type":"heading","depth":2,"position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"children":[{"type":"text","value":"Signatures","position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"key":"TX7rh2Rsi4"}],"identifier":"signatures","label":"Signatures","html_id":"signatures","implicit":true,"key":"hig31hj8JB"},{"type":"heading","depth":3,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"Q11lR8z74g"}],"identifier":"semantics","label":"Semantics","html_id":"semantics-1","implicit":true,"key":"lpvDuWTiV5"},{"type":"paragraph","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"children":[{"type":"text","value":"Signature is a collections of declarations; not evaluated, just type checked.","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"key":"z4SUOqui1c"}],"key":"A1B7VNrdF4"},{"type":"code","lang":"ocaml","value":"module type ModuleTypeName = sig \n  (* declarations *)\nend\n\nmodule type Stack = sig\n  type 'a stack\n  val empty    : 'a stack\n  val is_empty : 'a stack -> bool\n  val push     : 'a -> 'a stack -> 'a stack\n  val peek     : 'a stack -> 'a\n  val pop      : 'a stack -> 'a stack\nend","position":{"start":{"line":43,"column":1},"end":{"line":56,"column":1}},"key":"JfrRsigd5G"},{"type":"paragraph","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"children":[{"type":"text","value":"A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature.","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"key":"tY8gkuQjYu"}],"key":"ELXNzrReYp"},{"type":"paragraph","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"children":[{"type":"text","value":"If you don’t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we don’t have to do that. It’s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X.","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"key":"BSkQDmAO8u"}],"key":"bOZtAl2ux6"},{"type":"heading","depth":3,"position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"children":[{"type":"text","value":"Abstraction","position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"key":"SCEtim1RTF"}],"identifier":"abstraction","label":"Abstraction","html_id":"abstraction","implicit":true,"key":"dni3Yu7ikU"},{"type":"paragraph","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"children":[{"type":"text","value":"You can also specify that this module as a type of some signature by providing a module type annotation  ","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"aKdVCGf33Z"},{"type":"inlineCode","value":": Stack","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"sqemL4qLH5"},{"type":"text","value":". After adding this, everything inside that module will be come abstract and hidden from view.","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"CbTQF3Any5"}],"key":"xLnYmCU1qA"},{"type":"code","lang":"ocaml","value":"module type Arith = sig\n  type t\n  val zero  : t\n  val one   : t\n  val (+)   : t -> t -> t\n  val ( * ) : t -> t -> t\n  val (~-)  : t -> t\nend\n\nmodule Ints : Arith = struct\n  type t    = int\n  let zero  = 0\n  let one   = 1\n  let (+)   = Stdlib.(+)\n  let ( * ) = Stdlib.( * )\n  let (~-)  = Stdlib.(~-)\nend","position":{"start":{"line":66,"column":1},"end":{"line":84,"column":1}},"key":"jQo54GKDzH"},{"type":"paragraph","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"children":[{"type":"text","value":"Outside of the module ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"p9n1dE657M"},{"type":"inlineCode","value":"Ints","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"JWptcPnj4s"},{"type":"text","value":", the expression ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"nFPXgv7xuW"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"jQ1FaSa0MC"},{"type":"text","value":" is perfectly fine, but ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"PCHdRExvMU"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"AwR3NR92bk"},{"type":"text","value":" is not, because ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"t4stojpAZU"},{"type":"inlineCode","value":"t","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"MAilMvWAJC"},{"type":"text","value":" is abstract: outside the module no one is permitted to know that ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"KyQDxSJre6"},{"type":"inlineCode","value":"t = int","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"AEVHHNgtnK"},{"type":"text","value":". In fact, the toplevel can’t even give us good output about what the sum of one and one is!","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"kHlxSx0b0T"}],"key":"aKXknCCcz5"},{"type":"code","lang":"ocaml","value":"# Ints.(one + one);;\n- : Ints.t = <abstr>","position":{"start":{"line":88,"column":1},"end":{"line":91,"column":1}},"key":"vFqrpNaPkt"},{"type":"heading","depth":3,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Sharing Constraint","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"O34OHiZo3G"}],"identifier":"sharing-constraint","label":"Sharing Constraint","html_id":"sharing-constraint","implicit":true,"key":"f9zVJihWoa"},{"type":"paragraph","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"OCaml lets you write ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"BX5UF9Vsaq"},{"type":"emphasis","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"sharing constraints","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"x4RQH6TqrT"}],"key":"Djyeo4aOHC"},{"type":"text","value":" that refine a signature by specifying equations that must hold on the abstract types in that signature. If ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"PNGtNQU8U1"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"b5ScKypMZR"},{"type":"text","value":" is a module type containing an abstract type ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"OKZzr74PBo"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"buGyiJnGgo"},{"type":"text","value":", then ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"Ki2xKHXZw1"},{"type":"inlineCode","value":"T with type t = int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ftJu5GYiit"},{"type":"text","value":" is a new module type that is the same as ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"SUaW6FZwQv"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"s2MADyhnjX"},{"type":"text","value":", except that ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"SCJtgF2OBt"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"KQxWjLjw2L"},{"type":"text","value":" is known to be ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"qLTXWqUFfU"},{"type":"inlineCode","value":"int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"pwM4p6Mpj3"},{"type":"text","value":". For example, we could write:","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"xlGaP68YDz"}],"key":"H8yEUoALCR"},{"type":"code","lang":"ocaml","value":"module Ints : (Arith with type t = int) = struct\n  (* all of Ints as before *)\nend","position":{"start":{"line":97,"column":1},"end":{"line":101,"column":1}},"key":"LLO7CUy0az"},{"type":"paragraph","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Now both ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"UutsnB3g5l"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"hru89lmgji"},{"type":"text","value":" and ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"ac5uekz4fp"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"iSbTo2vXrT"},{"type":"text","value":" are legal.","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"hqKq1cVphJ"}],"key":"D0DTflcjta"},{"type":"heading","depth":3,"position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"Modules and the Top Level","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"vSV2t5vU3S"}],"identifier":"modules-and-the-top-level","label":"Modules and the Top Level","html_id":"modules-and-the-top-level","implicit":true,"key":"eWrnUeKT8X"},{"type":"paragraph","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"Well, apparently you cannot remember everything about how to import a library into OCaml and you don’t have to. So just refer to ","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"xWwRXWH89r"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"this site","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"d2FOf1jMLm"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","key":"kOCI9UglxT"}],"key":"hgdDUyu5Tu"}],"key":"hgSQLM7Wef"}],"key":"xCv0jdW82T"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"CS3110 Functional Programming"},"next":{"title":"Code Reuse with Modules","url":"/2020-02-13-code-reuse-with-modules","group":"CS3110 Functional Programming"}}},"domain":"http://localhost:3000"}