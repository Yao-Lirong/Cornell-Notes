{"version":2,"kind":"Article","sha256":"7c228b6bf6cf3854b535b0af059a0cf1f8a2c62aa291eca4be6d9b37b2b6a346","slug":"2020-02-11-modules","location":"/CS3110/2020-02-11-Modules.md","dependencies":[],"frontmatter":{"title":"Modules","tags":["Cornell","20SP","CS3110"],"date":"2020-02-11","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"2020-02-11-Modules.md","url":"/cornell-notes/build/2020-02-11-Modules-387880d5f7dacc9c0769791ed906f53a.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"From Textbook: ","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"ZM2pg4MAQJ"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"OCaml Modules","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"rqAfyDLI8F"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/ocaml_modules.html","key":"GbJKJrja7I"}],"key":"CnQhWISc4p"},{"type":"thematicBreak","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"MV02SZecOj"},{"type":"heading","depth":2,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Structures","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"d8WLxYXQHX"}],"identifier":"structures","label":"Structures","html_id":"structures","implicit":true,"key":"ezWY7GJShX"},{"type":"heading","depth":3,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"Jb4FO1UfOw"}],"identifier":"semantics","label":"Semantics","html_id":"semantics","implicit":true,"key":"AVf3dZh4zh"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"The first letter of a module’s name should be capitalized.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"JJimYJNa6X"}],"key":"g9O0OQyn7j"},{"type":"code","lang":"ocaml","value":"module ModuleName = struct \n  (* definitions *)\nend","position":{"start":{"line":20,"column":1},"end":{"line":24,"column":1}},"key":"XzprRXoYuN"},{"type":"comment","value":"more","key":"GcGp9rQgPM"},{"type":"paragraph","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"You can access the variables / methods in a module by ","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"oXlHlYsyDF"},{"type":"inlineCode","value":"Module.method","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"vsOGltdzTO"}],"key":"zd5sFo2tG7"},{"type":"code","lang":"ocaml","value":"let x = ModuleName.empty;;\nx.peek;;","position":{"start":{"line":30,"column":1},"end":{"line":33,"column":1}},"key":"U8Ik1ptCYU"},{"type":"heading","depth":2,"position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"children":[{"type":"text","value":"Signatures","position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"key":"hW3fyvPZnX"}],"identifier":"signatures","label":"Signatures","html_id":"signatures","implicit":true,"key":"yUKRZksCcV"},{"type":"heading","depth":3,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Semantics","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"pPcZZ9aHLT"}],"identifier":"semantics","label":"Semantics","html_id":"semantics-1","implicit":true,"key":"xFUTBBB4zA"},{"type":"paragraph","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"children":[{"type":"text","value":"Signature is a collections of declarations; not evaluated, just type checked.","position":{"start":{"line":41,"column":1},"end":{"line":41,"column":1}},"key":"CNaRmeNb9v"}],"key":"VURYGzAJLM"},{"type":"code","lang":"ocaml","value":"module type ModuleTypeName = sig \n  (* declarations *)\nend\n\nmodule type Stack = sig\n  type 'a stack\n  val empty    : 'a stack\n  val is_empty : 'a stack -> bool\n  val push     : 'a -> 'a stack -> 'a stack\n  val peek     : 'a stack -> 'a\n  val pop      : 'a stack -> 'a stack\nend","position":{"start":{"line":43,"column":1},"end":{"line":56,"column":1}},"key":"FxU5Yy3D1L"},{"type":"paragraph","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"children":[{"type":"text","value":"A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature.","position":{"start":{"line":58,"column":1},"end":{"line":58,"column":1}},"key":"uta0DjRvnC"}],"key":"wdEsJqkEUq"},{"type":"paragraph","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"children":[{"type":"text","value":"If you don’t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we don’t have to do that. It’s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X.","position":{"start":{"line":60,"column":1},"end":{"line":60,"column":1}},"key":"rfMr8htEbD"}],"key":"xHz46YvRg0"},{"type":"heading","depth":3,"position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"children":[{"type":"text","value":"Abstraction","position":{"start":{"line":62,"column":1},"end":{"line":62,"column":1}},"key":"FHX1MjtjHS"}],"identifier":"abstraction","label":"Abstraction","html_id":"abstraction","implicit":true,"key":"tYtyJhWw8v"},{"type":"paragraph","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"children":[{"type":"text","value":"You can also specify that this module as a type of some signature by providing a module type annotation  ","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"F1g8L9HyiY"},{"type":"inlineCode","value":": Stack","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"puPLjA4qXw"},{"type":"text","value":". After adding this, everything inside that module will be come abstract and hidden from view.","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"y9Yu3XBD6H"}],"key":"fmyN8sA423"},{"type":"code","lang":"ocaml","value":"module type Arith = sig\n  type t\n  val zero  : t\n  val one   : t\n  val (+)   : t -> t -> t\n  val ( * ) : t -> t -> t\n  val (~-)  : t -> t\nend\n\nmodule Ints : Arith = struct\n  type t    = int\n  let zero  = 0\n  let one   = 1\n  let (+)   = Stdlib.(+)\n  let ( * ) = Stdlib.( * )\n  let (~-)  = Stdlib.(~-)\nend","position":{"start":{"line":66,"column":1},"end":{"line":84,"column":1}},"key":"brp1nVKUoZ"},{"type":"paragraph","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"children":[{"type":"text","value":"Outside of the module ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"LEL9P040e1"},{"type":"inlineCode","value":"Ints","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"C1V8IVcYaw"},{"type":"text","value":", the expression ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"UJ4P2ejyI1"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"zpItAs8NN0"},{"type":"text","value":" is perfectly fine, but ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"ggbnR6J290"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"qkYmBfi2be"},{"type":"text","value":" is not, because ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"IRoUojn3k5"},{"type":"inlineCode","value":"t","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"wFsH8J6IJ2"},{"type":"text","value":" is abstract: outside the module no one is permitted to know that ","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"O2PhauV13y"},{"type":"inlineCode","value":"t = int","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"H3zGFpjbuv"},{"type":"text","value":". In fact, the toplevel can’t even give us good output about what the sum of one and one is!","position":{"start":{"line":86,"column":1},"end":{"line":86,"column":1}},"key":"SqQznBygZx"}],"key":"BYhvnIWvEr"},{"type":"code","lang":"ocaml","value":"# Ints.(one + one);;\n- : Ints.t = <abstr>","position":{"start":{"line":88,"column":1},"end":{"line":91,"column":1}},"key":"w9DZF2lM8k"},{"type":"heading","depth":3,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Sharing Constraint","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"MLNqqZS4qu"}],"identifier":"sharing-constraint","label":"Sharing Constraint","html_id":"sharing-constraint","implicit":true,"key":"D2cFiW5nbF"},{"type":"paragraph","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"OCaml lets you write ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"wzupuDecVG"},{"type":"emphasis","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"sharing constraints","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"jcOWEZVPJJ"}],"key":"dgHHPkG1NH"},{"type":"text","value":" that refine a signature by specifying equations that must hold on the abstract types in that signature. If ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"us7bjlENTn"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ZpzHfTF4Ac"},{"type":"text","value":" is a module type containing an abstract type ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"SXxggi3pZr"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"R5GOlbRlew"},{"type":"text","value":", then ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"AqcEbJoIxs"},{"type":"inlineCode","value":"T with type t = int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"OylSXDe9Gv"},{"type":"text","value":" is a new module type that is the same as ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"rZYLcgJixB"},{"type":"inlineCode","value":"T","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"Ue77CGzYFO"},{"type":"text","value":", except that ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ZfTZNbTSzk"},{"type":"inlineCode","value":"t","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"DXZqhmzaH5"},{"type":"text","value":" is known to be ","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"nl7L7U8sTN"},{"type":"inlineCode","value":"int","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"fVs0y0uQ6F"},{"type":"text","value":". For example, we could write:","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"Qub9uhmOjw"}],"key":"szgPIfL1qi"},{"type":"code","lang":"ocaml","value":"module Ints : (Arith with type t = int) = struct\n  (* all of Ints as before *)\nend","position":{"start":{"line":97,"column":1},"end":{"line":101,"column":1}},"key":"IR4G9c08AB"},{"type":"paragraph","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"text","value":"Now both ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"dCasSLVJSd"},{"type":"inlineCode","value":"Ints.(one + one)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"CH3kPpjnYn"},{"type":"text","value":" and ","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"jy2We7TXOu"},{"type":"inlineCode","value":"Ints.(1 + 1)","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"F7Z5RErLSe"},{"type":"text","value":" are legal.","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"mLx8dOe9HW"}],"key":"qsEhQBz7Dm"},{"type":"heading","depth":3,"position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"children":[{"type":"text","value":"Modules and the Top Level","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"knX8bBPTh3"}],"identifier":"modules-and-the-top-level","label":"Modules and the Top Level","html_id":"modules-and-the-top-level","implicit":true,"key":"xXW5G2WMHR"},{"type":"paragraph","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"Well, apparently you cannot remember everything about how to import a library into OCaml and you don’t have to. So just refer to ","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"uNvmr4qzyK"},{"type":"link","url":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"this site","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"TjezBWzfDi"}],"urlSource":"https://www.cs.cornell.edu/courses/cs3110/2020sp/textbook/modules/toplevel.html","key":"QiiVplZ2Oq"}],"key":"EclCu9xH49"}],"key":"vWZdz4GEAC"}],"key":"bHLMG5BIaw"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Higher-Order Functions","url":"/2020-02-06-higher-order-functions","group":"C S3110"},"next":{"title":"Code Reuse with Modules","url":"/2020-02-13-code-reuse-with-modules","group":"C S3110"}}},"domain":"http://localhost:3000"}